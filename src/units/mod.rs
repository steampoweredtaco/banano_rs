//! Units of Banano, i.e.
//! [Raw],
//! [Banano] (1<sup>29</sup>),
//! [Bananoshi] (1<sup>26</sup>).
//!
//! ## Example
//! ```
//! use banano_rs::units::{Banano, Bananoshi};
//! use std::convert::TryFrom;
//! use std::str::FromStr;
//!
//! # fn main() -> anyhow::Result<()> {
//! // One Bananoshi.
//! let bananoshi = Bananoshi::new(1);
//!
//! // Works with basic arithmetic.
//! let bananoshi = (bananoshi - Bananoshi::new(20)) / Bananoshi::new(2);
//!
//! // Can parse fractional strings.
//! assert_eq!(bananoshi, Bananoshi::from_str("-9.5")?);
//!
//! // Convert to banano.
//! let banano = bananoshi.to_banano();
//! assert_eq!(banano, Banano::from_str("-0.095")?);
//!
//! // Raw is a bounded type that does not allow values outside of u128, so this will fail because
//! // nano is currently negative.
//! assert!(banano.to_raw().is_err());
//!
//! let raw = Bananoshi::new(1).to_raw()?;
//! assert_eq!(raw.to_hex_string(), "00000000033B2E3C9FD0803CE8000000");
//! assert_eq!(raw.to_u128(), 1_000_000_000_000_000_000_000_000_000u128);
//!
//! # Ok(())
//! # }
//! ```
//!
//! # Raw differences
//! [Raw] acts differently than the other units in this module, as its internal type is [u128].
//! This means it can not be a value outside of that, i.e. negative numbers or bigger than
//! [u128::MAX]. To get around this, use [UnboundedRaw], which internally uses [BigDecimal].
//!
//! [Banano], [Bananoshi] and [UnboundedRaw] all use [BigDecimal] internally. These all act
//! in a similar way with conversions between themselves. See the example below.
//!
//! ## Example
//! ```
//! use banano_rs::units::Banano;
//!
//! let banano = Banano::new(1).to_bananoshi().to_unbounded_raw().to_bananoshi().to_banano();
//! assert_eq!(banano, Banano::new(1));
//! ```
//!
//! # Working with floats (f32, f64)
//! The general recommendation is to never use floats when dealing with money due to inaccuracies
//! with floating point precision. You can however do it with [BigDecimal]â€”see the example below.
//!
//! Ideally if your API doesn't support [BigDecimal], it might be better to convert between
//! [String] and [BigDecimal] to make sure there are no rounding or floating point inaccuracies.
//!
//! ## Example
//! ```
//! use banano_rs::units::Bananoshi;
//! use bigdecimal::{BigDecimal, FromPrimitive};
//! use std::str::FromStr;
//!
//! # fn main() -> anyhow::Result<()> {
//! // If you really need to load from a float, use BigDecimal.
//! let big = BigDecimal::from_f64(1231239999999999.1).unwrap();
//! let bananoshi = Bananoshi::new(big);
//!
//! // Convert to float.
//! assert_eq!(bananoshi.to_f64(), 1231239999999999.1);
//!
//! // Better
//! let big = BigDecimal::from_str("9999999999.1").unwrap();
//! let bananoshi = Bananoshi::new(big);
//! assert_eq!(bananoshi.to_string(), "9999999999.1");
//!
//! # Ok(())
//! # }
//! ```
pub(crate) mod raw;

use crate::Error;
use bigdecimal::BigDecimal;
use bigdecimal::ToPrimitive;
use doc_comment::doc_comment;
use once_cell::sync::Lazy;
pub use raw::Raw;
use std::convert::TryFrom;
use std::str::FromStr;

/// This macro creates a struct to handle a specific denomination with arithmetic and conversions
/// to/from [Raw].
macro_rules! unit {
    ($struct_name:ident, $multiplier:expr) => {
        doc_comment! {
        concat!("The ", stringify!($struct_name), " (10<sup>", stringify!($multiplier) ,"</sup> raw) unit denomination.
        
See the [module documentation](crate::units) for more information as this is generated by a macro and it's tricky to write docs for it :).
        "),
        #[derive(Debug, Clone, Eq, PartialEq)]
        pub struct $struct_name(BigDecimal);
        }

        impl $struct_name {
            fn lazy_multiplier() -> Lazy<BigDecimal> {
                let multiplier: Lazy<BigDecimal> = Lazy::new(|| {
                    let value = 10u128.pow($multiplier);
                    // For some reason from_u128 fails with `None`.
                    BigDecimal::from_str(value.to_string().as_str()).unwrap()
                });
                multiplier
            }

            pub fn new<T: Into<BigDecimal>>(v: T) -> Self {
                Self(v.into())
            }

            /// When initializing, use a raw value intsead of this unit type.
            /// ```
            /// # use banano_rs::units::Bananoshi;
            /// # use bigdecimal::BigDecimal;
            /// # use std::str::FromStr;
            /// # fn main() -> anyhow::Result<()> {
            /// let decimal = BigDecimal::from_str("1_000_000_000_000_000_000_000_000_000")?;
            /// let bananoshi = Bananoshi::new_with_raw(decimal);
            /// assert_eq!(bananoshi, Bananoshi::new(1));
            /// # Ok(())
            /// # }
            /// ```
            pub fn new_with_raw<T: Into<BigDecimal>>(v: T) -> Self {
                Self(v.into() / &*Self::lazy_multiplier())
            }

            /// Returns a [Raw].
            ///
            /// If the converted amount is out of range of `0..u128::MAX` it will return an error.
            /// ```
            /// # use banano_rs::units::Bananoshi;
            /// # use bigdecimal::BigDecimal;
            /// # use std::str::FromStr;
            /// # use bigdecimal::FromPrimitive;
            /// # use banano_rs::Raw;
            /// # fn main() -> anyhow::Result<()> {
            /// let bananoshi = Bananoshi::new(BigDecimal::from_str("0.000000000000000000000000001")?);
            /// let raw = bananoshi.to_raw()?;
            /// assert_eq!(raw, Raw::new(1u128));
            /// # Ok(())
            /// # }
            /// ```
            pub fn to_raw(&self) -> Result<Raw, Error> {
                Raw::try_from(&self.to_raw_big_decimal())
            }

            pub fn to_unbounded_raw(&self) -> UnboundedRaw {
                UnboundedRaw::new(self.to_raw_big_decimal())
            }

            pub fn to_banano(&self) -> Banano {
                Banano::new_with_raw(self.to_raw_big_decimal())
            }

            pub fn to_bananoshi(&self) -> Bananoshi {
                Bananoshi::new_with_raw(self.to_raw_big_decimal())
            }

            pub fn to_f64(&self) -> f64 {
                // TODO: unwrap ok here?
                self.0.to_f64().unwrap()
            }

            /// Returns a [BigDecimal] with the value of this type.
            /// ```
            /// # use banano_rs::units::Banano;
            /// # use bigdecimal::BigDecimal;
            /// # use std::str::FromStr;
            /// # use bigdecimal::FromPrimitive;
            /// # fn main() -> anyhow::Result<()> {
            /// let banano = Banano::new(1);
            /// let decimal = banano.to_big_decimal();
            /// assert_eq!(decimal, &BigDecimal::from_str("1")?);
            /// # Ok(())
            /// # }
            /// ```
            pub fn to_big_decimal(&self) -> &BigDecimal {
                &self.0
            }

            /// Returns a [BigDecimal] with the raw value.
            /// ```
            /// # use banano_rs::units::Banano;
            /// # use bigdecimal::BigDecimal;
            /// # use std::str::FromStr;
            /// # fn main() -> anyhow::Result<()> {
            /// let banano = Banano::new(1);
            /// let decimal = banano.to_raw_big_decimal();
            /// assert_eq!(decimal, BigDecimal::from_str("100000000000000000000000000000")?);
            /// # Ok(())
            /// # }
            /// ```
            pub fn to_raw_big_decimal(&self) -> BigDecimal {
                &self.0 * &*Self::lazy_multiplier()
            }
        }

        impl ToString for $struct_name {
            fn to_string(&self) -> String {
                self.0.to_string()
            }
        }

        impl FromStr for $struct_name {
            type Err = Error;

            fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                Ok(Self::new(BigDecimal::from_str(s)?))
            }
        }

        impl From<Raw> for $struct_name {
            fn from(raw: Raw) -> Self {
                // TODO: unwrap ok here?
                // TODO: from_u128 returns None for some reason...
                let big_dec = BigDecimal::from_str(raw.0.to_string().as_str()).unwrap();
                Self(big_dec / &*Self::lazy_multiplier())
            }
        }

        impl From<&Raw> for $struct_name {
            fn from(raw: &Raw) -> Self {
                Self::from(raw.clone())
            }
        }

        impl std::ops::Add for $struct_name {
            type Output = Self;

            fn add(self, rhs: Self) -> Self::Output {
                Self::new(self.0 + rhs.0)
            }
        }

        impl std::ops::Sub for $struct_name {
            type Output = Self;

            fn sub(self, rhs: Self) -> Self::Output {
                Self::new(self.0 - rhs.0)
            }
        }

        impl std::ops::Div for $struct_name {
            type Output = Self;

            fn div(self, rhs: Self) -> Self::Output {
                Self::new(self.0 / rhs.0)
            }
        }

        impl std::ops::Mul for $struct_name {
            type Output = Self;

            fn mul(self, rhs: Self) -> Self::Output {
                Self::new(self.0 * rhs.0)
            }
        }

        impl std::ops::AddAssign for $struct_name {
            fn add_assign(&mut self, rhs: Self) {
                self.0 += rhs.0;
            }
        }

        impl std::ops::SubAssign for $struct_name {
            fn sub_assign(&mut self, rhs: Self) {
                self.0 -= rhs.0;
            }
        }

        impl std::ops::MulAssign for $struct_name {
            fn mul_assign(&mut self, rhs: Self) {
                self.0 *= rhs.0;
            }
        }

        // TODO: binary assignment operation `/=` cannot be applied to type `bigdecimal::BigDecimal`
        // impl std::ops::DivAssign for $struct_name {
        //     fn div_assign(&mut self, rhs: Self) {
        //         self.0 /= rhs.0;
        //     }
        // }
    };
}

unit!(Banano, 29);
unit!(Bananoshi, 27);
unit!(UnboundedRaw, 0);

#[cfg(test)]
mod tests {
    use super::*;
    use bigdecimal::FromPrimitive;

    #[test]
    fn conversion_banano_to_bananoshi() {
        let hundred_bananoshi = Banano::new(1)
            .to_bananoshi();
        assert_eq!(hundred_bananoshi, Bananoshi::new(100));
    }

    #[test]
    fn banano_overflow() {
        let d = BigDecimal::from_str("3402823669.20938463463374607431768211455").unwrap();
        Banano::new(d).to_raw().unwrap();

        // One over the max
        let d = BigDecimal::from_str("3402823669.20938463463374607431768211456").unwrap();
        assert!(Banano::new(d).to_raw().is_err());
    }

    #[test]
    fn is_something_wrong_with_big_decimal_u128() {
        assert_eq!(
            u64::MAX.to_string(),
            BigDecimal::from_u64(u64::MAX).unwrap().to_string()
        );
        // TODO: This doesn't work
        // assert_eq!(
        //     u128::MAX.to_string(),
        //     BigDecimal::from_u128(u128::MAX).unwrap().to_string()
        // );
    }

    #[test]
    fn arithmetic() {
        assert_eq!(Banano::new(1) + Banano::new(-2), Banano::new(-1));
        assert_eq!(Banano::new(2) - Banano::new(1), Banano::new(1));
        assert_eq!(Banano::new(10) / Banano::new(2), Banano::new(5));
        assert_eq!(Banano::new(10) * Banano::new(2), Banano::new(20));

        let mut n = Banano::new(1);
        n += Banano::new(2);
        assert_eq!(n, Banano::new(3));
        n -= Banano::new(1);
        assert_eq!(n, Banano::new(2));
        n *= Banano::new(4);
        assert_eq!(n, Banano::new(8));
    }
}